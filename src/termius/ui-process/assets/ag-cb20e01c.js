const e="Recursively search for PATTERN in PATH. Like grep or ack, but faster",i="ag",n=[{name:"pattern",isOptional:!0},{name:"path",template:["filepaths"],isVariadic:!0,isOptional:!0}],t=[{description:"Output results in a format parseable by AckMate https://github.com/protocool/AckMate",name:"--ackmate"},{description:"Set thread affinity (if platform supports it)",name:"--affinity"},{description:"Don't set thread affinity (if platform supports it)",name:"--noaffinity"},{description:"Search all files. This doesn't include hidden files, and doesn't respect any ignore files",name:["-a","--all-types"]},{description:"Print lines after match",name:["-A","--after"],args:[{name:"LINES",description:"The amount of lines",isOptional:!0}]},{description:"Print lines before match",name:["-B","--before"],args:[{name:"LINES",description:"The amount of lines",isOptional:!0}]},{description:"Print a newline between matches in different files. Enabled by default",name:"--nobreak"},{description:"Only  print the number of matches in each file. Note: This is the number of matches, not the number of matching lines. Pipe output to wc -l if you want the number of matching lines",name:["-c","--count"]},{description:"Print color codes in results",name:"--color"},{description:"Don't print color codes in results",name:"--nocolor"},{description:"Color codes for line numbers. Default is 1;33",name:"--color-line-number"},{description:"Color codes for result match numbers. Default is 30;43",name:"--color-match"},{description:"Color codes for path names. Default is 1;32",name:"--color-path"},{description:"Print column numbers in results",name:"--column"},{description:"Print lines before and after matches",name:["-C","--context"],args:[{name:"LINES",description:"The amount of lines",isOptional:!0}]},{description:"Output ridiculous amounts of debugging info. Not useful unless you're actually debugging",name:["-D","--debug"]},{description:"Search up to NUM directories deep, -1 for unlimited",name:"--depth",args:[{name:"NUM",description:"The depth in directories to search",isOptional:!0}]},{description:"Print file names",name:"--filename"},{description:"Don't print file names",name:"--nofilename"},{description:"Follow symlinks",name:["-f","--follow"]},{description:"Don't follow symlinks",name:"--nofollow"},{description:"Alias for --literal for compatibility with grep",name:["-F","--fixed-strings"]},{description:"Lumps multiple matches in the same file together, and presents them under a single occurrence of the filename",name:"--group"},{description:"Refrains from lumping matches in the same file together, and instead places the filename at the start of each match line",name:"--nogroup"},{description:"Print filenames matching PATTERN",name:"-g",args:[{name:"PATTERN",description:"The pattern to look for"}]},{description:"Only search files whose names match PATTERN",name:["-G","--file-search-regex"],args:[{name:"PATTERN",description:"The pattern to look for"}]},{description:"Print filenames above matching contents",name:["-H","--heading"]},{description:"Don't print filenames above matching contents",name:"--noheading"},{description:"Search hidden files. This option obeys ignored files",name:"--hidden"},{description:"Ignore files/directories whose names match this pattern. Literal file and directory names are also allowed",name:"--ignore",args:[{name:"PATTERN",description:"The pattern to look for",template:["filepaths","folders"]}]},{description:"Alias for --ignore for compatibility with ack",name:"--ignore-dir",args:[{name:"NAME",description:"The directory to ignore",template:["filepaths","folders"]}]},{description:"Match case-insensitively",name:["-i","--ignore-case"]},{description:"Only print the names of files containing matches, not the matching lines. An empty query will print all files that would be searched",name:["-l","--files-with-matches"]},{description:"Only print the names of files that don't contain matches",name:["-L","--files-without-matches"]},{description:"See FILE TYPES below",name:"--list-file-types"},{description:"Skip the rest of a file after NUM matches. Default is 0, which never skips",name:["-m","--max-count"],args:[{name:"NUM",description:"The number of matches to skip after",isOptional:!0}]},{description:"Use of memory-mapped I/O. Defaults to true on platforms where mmap() is faster than read(). (All but macOS.)",name:"--mmap"},{description:"Don't use of memory-mapped I/O. Defaults to true on platforms where mmap() is faster than read(). (All but macOS.)",name:"--nommap"},{description:"Match regexes across newlines",name:"--multiline"},{description:"Don't match regexes across newlines",name:"--nomultiline"},{description:"Don't recurse into directories",name:["-n","--norecurse"]},{description:"Print line numbers",name:"--numbers"},{description:"Don't print line numbers",name:"--nonumbers"},{description:"Print only the matching part of the lines",name:["-o","--only-matching"]},{description:"When  recursing  directories, don't scan dirs that reside on other storage devices. This lets you avoid scanning slow network mounts. This feature is not supported on all platforms",name:"--one-device"},{description:"Provide a path to a specific .ignore file",name:["-p","--path-to-ignore"],args:[{name:"STRING",description:"The path to the ignore file",template:["filepaths"]}]},{description:"Use a pager such as less. Use --nopager to override. This option is also ignored if output is piped to another program",name:"--pager",args:[{name:"COMMAND",description:"The pager",suggestions:["more","less","most"]}]},{description:`Parse the input stream as a search term, not data to search. This is meant to be  used  with  tools  such  as  GNU  parallel.  For  example:  echo "foo
bar
baz" | parallel "ag {} ." will run 3 instances of ag, searching the current directory for "foo", "bar", and "baz"`,name:"--parallel"},{description:"Print matches on very long lines (> 2k characters by default)",name:"--print-long-lines"},{description:"When searching a stream, print all lines even if they don't match",name:["--passthrough","--passthru"]},{description:"Do not parse PATTERN as a regular expression. Try to match it literally",name:["-Q","--literal"]},{description:"Recurse into directories when searching. Default is true",name:["-r","--recurse"]},{description:"Match case-sensitively",name:["-s","--case-sensitive"]},{description:"Match case-sensitively if there are any uppercase letters in PATTERN, case-insensitively otherwise. Enabled by default",name:["-S","--smart-case"]},{description:"Search binary files for matches",name:"--search-binary"},{description:"Suppress all log messages, including errors",name:"--silent"},{description:"Print stats (files scanned, time taken, etc)",name:"--stats"},{description:"Print stats (files scanned, time taken, etc) and nothing else",name:"--stats-only"},{description:"Search all text files. This doesn't include hidden files",name:["-t","--all-text"]},{description:"Search all files. This ignores .ignore, .gitignore, etc. It searches binary and hidden files as well",name:["-u","--unrestricted"]},{description:"Ignore VCS ignore files (.gitignore, .hgignore), but still use .ignore",name:["-U","--skip-vcs-ignores"]},{description:"Match every line not containing the specified pattern",name:["-v","--invert-match"]},{description:"Print version info",name:["-V","--version"]},{description:"Output results in the same form as Vim's :vimgrep /pattern/g Here is a ~/.vimrc configuration example: set grepprg=ag --vimgrep $* set grepformat=%f:%l:%c:%m Then use :grep to grep for something. Then use :copen, :cn, :cp, etc. to navigate through the matches",name:"--vimgrep"},{description:"Only match whole words",name:["-w","--word-regexp"]},{description:"Use NUM worker threads. Default is the number of CPU cores, with a max of 8",name:"--workers",args:[{name:"NUM",description:"The NUM of worker threads",isOptional:!0}]},{description:"Search contents of compressed files. Currently, gz and xz are supported. This option requires that ag is built with lzma and zlib",name:["-z","--search-zip"]},{description:`Separate the filenames with \0, rather than 
: this allows xargs -0 <command> to correctly process filenames containing spaces or newlines`,name:["-0","--null","--print0"]}],s={description:e,name:i,args:n,options:t};export{n as args,s as default,e as description,i as name,t as options};
//# sourceMappingURL=ag-cb20e01c.js.map

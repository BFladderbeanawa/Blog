const e="Interpreted object-oriented scripting language",t="ruby",i=[{description:"Prints the copyright notice",name:"--copyright"},{description:"Prints the version of Ruby interpreter",name:"--version"},{description:"Specifies the input record separator ($/) as an octal number",name:"-0",args:[{name:"octal"}]},{description:"Causes Ruby to switch to the directory",name:"-C",args:[{name:"directory",template:["folders"]}]},{description:"Specifies input field separator ($;)",name:"-F",args:[{name:"pattern"}]},{description:"Used to tell Ruby where to load the library scripts. Directory path will be added to the load-path variable ($:)",name:"-I",args:[{name:"directory",template:["folders"]}]},{description:"Specifies KANJI (Japanese) encoding",name:"-K",args:[{name:"kcode"}]},{description:"Makes Ruby use the PATH environment variable to search for script, unless its name begins with a slash. This is used to emulate #! on machines that don't support it, in the following manner: #! /usr/local/bin/ruby # This line makes the next one a comment in Ruby \\ exec /usr/local/bin/ruby -S $0 $*",name:"-S"},{description:"Turns on taint checks at the specified level (default 1)",name:"-T",args:[{name:"level"}]},{description:"Turns on auto-split mode when used with -n or -p",name:"-a"},{description:"Causes Ruby to check the syntax of the script and exit without executing. If there are no syntax errors, Ruby will print “Syntax OK” to the standard output",name:"-c"},{description:"Turns on debug mode. $DEBUG will be set to true",name:["-d","--debug"]},{description:"Specifies script from command-line while telling Ruby not to search the rest of arguments for a script file name",name:"-e",args:[{name:"command"}]},{description:"Prints a summary of the options",name:["-h","--help"]},{description:"Specifies in-place-edit mode. The extension, if specified, is added to old file name to make a backup copy",name:"-i",args:[{name:"extension",isOptional:!0}]},{description:"Enables automatic line-ending processing, which means to firstly set $\\ to the value of $/, and secondly chops every line read using chop!",name:"-l"},{description:"Causes Ruby to assume the following loop around your script",name:"-n"},{description:"Acts mostly same as -n switch, but print the value of variable $_ at the each end of the loop",name:"-p"},{description:"Causes Ruby to load the library using require",name:"-r",args:[{name:"library"}]},{description:"Enables some switch parsing for switches after script name but before any file name arguments (or before a --)",name:"-s"},{description:"Enables verbose mode",name:["-v","--verbose"]},{description:"Enables verbose mode without printing version message at the beginning. It sets the $VERBOSE variable to true",name:"-w"},{description:"Tells Ruby that the script is embedded in a message. Leading garbage will be discarded until the first that starts with “#!” and contains the string, “ruby”. Any meaningful switches on that line will applied. The end of script must be specified with either EOF, ^D (control-D), ^Z (control-Z), or reserved word __END__. If the directory name is specified, Ruby will switch to that directory before executing script",name:"-x",args:[{name:"directory",template:["folders"]}]},{description:"Turns on compiler debug mode. Ruby will print a bunch of internal state messages during compiling scripts. You don't have to specify this switch, unless you are going to debug the Ruby interpreter",name:["-y","--yydebug"]}],n={description:e,name:t,options:i};export{n as default,e as description,t as name,i as options};
//# sourceMappingURL=ruby-efaf5b7c.js.map

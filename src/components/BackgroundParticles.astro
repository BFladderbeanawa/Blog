<canvas id="bg-canvas"></canvas>

<style>
    #bg-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: -1; /* Ensure it stays behind everything */
        pointer-events: none; /* Allow clicks to pass through */
    }
</style>

<script>
    class ParticleNetwork {
        constructor() {
            this.canvas = document.getElementById('bg-canvas');
            this.ctx = this.canvas.getContext('2d');
            this.particles = [];
            this.mouse = { x: null, y: null, radius: 150 };
            
            // Configuration
            this.config = {
                particleColor: 'rgba(0, 0, 0, 0.15)', // Light gray for day (approx #ececec)
                lineColor: 'rgba(0, 0, 0, 0.08)',
                particleCount: 0, // Will be calculated based on screen size
                connectionDistance: 120,
                baseSpeed: 0.5,
                repulseForce: 5 // How hard the mouse pushes
            };

            this.init();
            this.animate();
            this.handleEvents();
        }

        init() {
            this.resize();
            this.updateThemeColors();
        }

        updateThemeColors() {
            // Check for current theme to adjust colors
            const isDark = document.documentElement.getAttribute('data-theme') === 'nord';
            if (isDark) {
                this.config.particleColor = 'rgba(255, 255, 255, 0.25)';
                this.config.lineColor = 'rgba(255, 255, 255, 0.15)';
                this.canvas.style.zIndex = '0';
            } else {
                // User requested very faint #f0f0f0-ish look. 
                // On white bg, #f0f0f0 is invisible, so we use low opacity black to achieve "light gray" visual
                this.config.particleColor = 'rgba(0, 0, 0, 0.15)'; 
                this.config.lineColor = 'rgba(0, 0, 0, 0.08)';
                this.canvas.style.zIndex = '-1';
            }
        }

        resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            
            // Calculate appropriate number of particles based on screen area
            // Fewer particles = cleaner look
            const area = this.canvas.width * this.canvas.height;
            this.config.particleCount = Math.floor(area / 15000); 

            this.createParticles();
        }

        createParticles() {
            this.particles = [];
            for (let i = 0; i < this.config.particleCount; i++) {
                this.particles.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    vx: (Math.random() - 0.5) * this.config.baseSpeed,
                    vy: (Math.random() - 0.5) * this.config.baseSpeed,
                    size: Math.random() * 2 + 1,
                    baseX: null, // For returning to original path if we wanted elastic, but here we just float
                    baseY: null
                });
            }
        }

        handleEvents() {
            window.addEventListener('resize', () => this.resize());
            
            window.addEventListener('mousemove', (e) => {
                this.mouse.x = e.x;
                this.mouse.y = e.y;
            });

            window.addEventListener('mouseleave', () => {
                this.mouse.x = null;
                this.mouse.y = null;
            });

            // Observer for theme changes to update color instantly
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'data-theme') {
                        this.updateThemeColors();
                    }
                });
            });
            observer.observe(document.documentElement, { attributes: true });
        }

        draw() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            for (let i = 0; i < this.particles.length; i++) {
                let p = this.particles[i];

                // 1. Move
                p.x += p.vx;
                p.y += p.vy;

                // 2. Mouse Repulsion / Attraction
                if (this.mouse.x != null) {
                    let dx = this.mouse.x - p.x;
                    let dy = this.mouse.y - p.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);

                    // Connect Mouse to Particle
                    if (distance < this.mouse.radius) {
                        this.ctx.beginPath();
                        this.ctx.strokeStyle = this.config.lineColor;
                        this.ctx.lineWidth = 1 - (distance / this.mouse.radius);
                        this.ctx.moveTo(p.x, p.y);
                        this.ctx.lineTo(this.mouse.x, this.mouse.y);
                        this.ctx.stroke();
                    }

                    if (distance < this.mouse.radius) {
                        const forceDirectionX = dx / distance;
                        const forceDirectionY = dy / distance;
                        const force = (this.mouse.radius - distance) / this.mouse.radius;
                        const directionX = forceDirectionX * force * this.config.repulseForce;
                        const directionY = forceDirectionY * force * this.config.repulseForce;

                        // Repulse (push away)
                        p.x -= directionX;
                        p.y -= directionY;
                    }
                }

                // 3. Bounce off edges
                if (p.x < 0 || p.x > this.canvas.width) p.vx = -p.vx;
                if (p.y < 0 || p.y > this.canvas.height) p.vy = -p.vy;

                // 4. Draw Particle
                this.ctx.fillStyle = this.config.particleColor;
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                this.ctx.fill();

                // 5. Draw Connections
                for (let j = i; j < this.particles.length; j++) {
                    let p2 = this.particles[j];
                    let dx = p.x - p2.x;
                    let dy = p.y - p2.y;
                    let distance = Math.sqrt(dx*dx + dy*dy);

                    if (distance < this.config.connectionDistance) {
                        this.ctx.beginPath();
                        this.ctx.strokeStyle = this.config.lineColor;
                        this.ctx.lineWidth = 1 - (distance / this.config.connectionDistance); // Fade out line
                        this.ctx.moveTo(p.x, p.y);
                        this.ctx.lineTo(p2.x, p2.y);
                        this.ctx.stroke();
                    }
                }
            }
        }

        animate() {
            this.draw();
            requestAnimationFrame(this.animate.bind(this));
        }
    }

    // Init on page load and astro transitions
    document.addEventListener('astro:page-load', () => {
        // Prevent multiple canvases if one already exists/running context (cleanup handled by replacement mostly but good to be safe)
        const canvas = document.getElementById('bg-canvas');
        if (canvas) {
            new ParticleNetwork();
        }
    });
</script>
